1) Crear carpeta del proyecto y abrirla
mkdir api-estudiantes
cd api-estudiantes
code .   # abre VS Code en esa carpeta


  2) Crear entorno virtual y activarlo (Windows)
python -m venv venv
# Activar:
venv\Scripts\activate

3) Instalar dependencias
pip install --upgrade pip
pip install fastapi uvicorn psycopg2-binary pydantic

4) Estructura de archivos

Crea en VS Code los archivos:

api-estudiantes/
  ├ main.py
  ├ database.py
  ├ models.py
  └ requirements.txt  

  5) Contenido de cada archivo 
database.py
import psycopg2
from psycopg2.extras import RealDictCursor
from contextlib import contextmanager

# CAMBIA 'tu_password' por la contraseña real del usuario postgres
DB_CONFIG = {
    'host': 'localhost',
    'database': 'escuela_db',
    'user': 'postgres',
    'password': 'tu_password'
}

@contextmanager
def get_db_connection():
    conn = psycopg2.connect(**DB_CONFIG, cursor_factory=RealDictCursor)
    try:
        yield conn
        conn.commit()
    except Exception as e:
        conn.rollback()
        raise e
    finally:
        conn.close()

          #models.py

from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class EstudianteBase(BaseModel):
    nombre: str = Field(..., min_length=1, max_length=100)
    edad: int = Field(..., ge=15, le=100)
    carrera: str = Field(..., max_length=100)
    promedio: float = Field(..., ge=0, le=100)

class EstudianteCreate(EstudianteBase):
    pass

class EstudianteUpdate(BaseModel):
    nombre: Optional[str] = Field(None, min_length=1, max_length=100)
    edad: Optional[int] = Field(None, ge=15, le=100)
    carrera: Optional[str] = Field(None, max_length=100)
    promedio: Optional[float] = Field(None, ge=0, le=100)

class EstudianteResponse(EstudianteBase):
    id: int
    fecha_registro: datetime

    class Config:
        from_attributes = True

#Main.py


from fastapi import FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from typing import List
from models import EstudianteCreate, EstudianteUpdate, EstudianteResponse
from database import get_db_connection

app = FastAPI(
    title="API de Gestión de Estudiantes",
    description="CRUD completo para gestionar estudiantes",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # en producción define dominios específicos
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# CREATE
@app.post("/estudiantes/", response_model=EstudianteResponse, status_code=status.HTTP_201_CREATED)
async def crear_estudiante(estudiante: EstudianteCreate):
    with get_db_connection() as conn:
        cursor = conn.cursor()
        query = """
        INSERT INTO estudiantes (nombre, edad, carrera, promedio)
        VALUES (%s, %s, %s, %s)
        RETURNING *
        """
        cursor.execute(query, (
            estudiante.nombre,
            estudiante.edad,
            estudiante.carrera,
            estudiante.promedio
        ))
        nuevo_estudiante = cursor.fetchone()
        if not nuevo_estudiante:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Error al crear el estudiante")
        return nuevo_estudiante

# READ ALL
@app.get("/estudiantes/", response_model=List[EstudianteResponse])
async def obtener_estudiantes(skip: int = 0, limit: int = 100):
    with get_db_connection() as conn:
        cursor = conn.cursor()
        query = """
        SELECT * FROM estudiantes
        ORDER BY id
        LIMIT %s OFFSET %s
        """
        cursor.execute(query, (limit, skip))
        estudiantes = cursor.fetchall()
        return estudiantes

# READ ONE
@app.get("/estudiantes/{estudiante_id}", response_model=EstudianteResponse)
async def obtener_estudiante(estudiante_id: int):
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM estudiantes WHERE id = %s", (estudiante_id,))
        estudiante = cursor.fetchone()
        if not estudiante:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Estudiante con ID {estudiante_id} no encontrado")
        return estudiante

# UPDATE
@app.put("/estudiantes/{estudiante_id}", response_model=EstudianteResponse)
async def actualizar_estudiante(estudiante_id: int, estudiante: EstudianteUpdate):
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM estudiantes WHERE id = %s", (estudiante_id,))
        estudiante_existente = cursor.fetchone()
        if not estudiante_existente:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Estudiante con ID {estudiante_id} no encontrado")

        campos_actualizar = []
        valores = []
        if estudiante.nombre is not None:
            campos_actualizar.append("nombre = %s")
            valores.append(estudiante.nombre)
        if estudiante.edad is not None:
            campos_actualizar.append("edad = %s")
            valores.append(estudiante.edad)
        if estudiante.carrera is not None:
            campos_actualizar.append("carrera = %s")
            valores.append(estudiante.carrera)
        if estudiante.promedio is not None:
            campos_actualizar.append("promedio = %s")
            valores.append(estudiante.promedio)

        if not campos_actualizar:
            return estudiante_existente

        valores.append(estudiante_id)
        query = f"""
        UPDATE estudiantes
        SET {', '.join(campos_actualizar)}
        WHERE id = %s
        RETURNING *
        """
        cursor.execute(query, valores)
        estudiante_actualizado = cursor.fetchone()
        return estudiante_actualizado

# DELETE
@app.delete("/estudiantes/{estudiante_id}", status_code=status.HTTP_204_NO_CONTENT)
async def eliminar_estudiante(estudiante_id: int):
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM estudiantes WHERE id = %s", (estudiante_id,))
        estudiante = cursor.fetchone()
        if not estudiante:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Estudiante con ID {estudiante_id} no encontrado")
        cursor.execute("DELETE FROM estudiantes WHERE id = %s", (estudiante_id,))
        return None

# ROOT
@app.get("/")
async def root():
    return {
        "mensaje": "API de Gestión de Estudiantes",
        "version": "1.0.0",
        "endpoints": {
            "crear": "POST /estudiantes/",
            "listar": "GET /estudiantes/",
            "obtener": "GET /estudiantes/{id}",
            "actualizar": "PUT /estudiantes/{id}",
            "eliminar": "DELETE /estudiantes/{id}"
        }
    }

# Para ejecutar con python main.py (opcional)
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)

  #Ejecutar la api
  6) Ejecutar la API

En la terminal  ejecuta:

uvicorn main:app --reload --host 0.0.0.0 --port 8000

  #Abrir con el navegador 
  http://localhost:8000/docs





